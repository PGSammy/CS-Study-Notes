# Chapter 03. 컴퓨터 구조 (Computer Architecture)
---
## 목차
---
1. [운영체제 개요](#운영체제-개요)
- [운영체제 역할](#운영체제-역할)
- [시스템 콜과 이중모드](#시스템-콜과-이중모드)
2. [프로세스와 스레드](#프로세스와-스레드)
- [멀티프로세스와 멀티스레드](#멀티프로세스와-멀티스레드)
- [프로세스간 통신](#프로세스간-통신)
3. [동기화와 교착상태](#동기화와-교착상태)
- [동기화 기법](#동기화-기법)
- [교착 상태](#교착-상태)
4. [CPU 스케줄링](#CPU-스케줄링)
- [CPU 스케줄링 알고리즘](#CPU-스케줄링-알고리즘)
- [리눅스 CPU 스케줄링](#리눅스-CPU-스케줄링)
5. [가상 메모리](#가상-메모리)
- [물리 주소와 논리 주소](#물리-주소와-논리-주소)
- [스와핑과 연속메모리 할당](#스와핑과-연속메모리-할당)
- [페이징을 통한 가상메모리 관리](#페이징을-통한-가상메모리-관리)
- [페이지 교체 알고리즘](#페이지-교체-알고리즘)
6. [파일 시스템](#파일-시스템)
- [파일과 디렉터리](#파일과-디렉터리)
- [파일 시스템](#파일-시스템)
7. [별첨](#별첨)
- [부팅](#부팅)
- [가상머신과 컨테이너](#가상머신과-컨테이너)

## 운영체제 개요
---
- 운영체제 : 윈도우, 맥OS, 리눅스는 데스크탑 운영체제이고 Android와 iOs는 스마트폰 운영체제
- 커널(kernel) : 운영체제의 핵심 기능을 담당하는 부분 (ex : 자동차 엔진, 사람의 심장)
- 운영체제의 기능에는 **자원 할당 및 관리**의 기능과 **프로세스 및 스레드 관리**의 기능 총 2가지 기능을 가지고 있다.

### 운영체제 역할
---
- 자원(resource) : 프로그램 실행에 마땅히 필요한 요소로 데이터 자원은 '소프트웨어'라고 하고, 실행에 필요한 부품은 '하드웨어'라고 지칭한다.

#### CPU 관리: CPU 스케줄링
- 운영체제는 실행 중인 프로그램들이 공정하고 합리적으로 CPU를 할당 받을 수 있도록 할당 순서와 사용 시간을 결정해야 하는데, 이를 스케줄링이라고 한다.

#### 메모리 관리 : 가상 메모리
- 낭비되는 메모리 용량이 없도록 효율적으로 메모리를 관리하는 방법이 가상 메모리로, 실제 물리적 메모리 크기보다 더 큰 메모리를 이용할 수 있다.

#### 파일/디렉터리 관리 : 파일 시스템
- 보조기억장치를 효율적으로 관리하기 위해 사용되는 '파일 시스템'이 있다.

#### 프로세스 및 스레드 관리
- 프로세스 : 실행 중인 프로그램
- 스레드(thread) : 프로세스를 이루는 실행의 단위
- 운영체제는 동시다발적으로 실행되는 프로세스와 스레드가 올바르게 처리되도록 실행의 순서 제어하며 자원을 적절히 배분해야 한다.

### 시스템 콜과 이중 모드
---
- 커널 영역(kernel space) : 메모리 내의 특수한 공간 (운영체제가 담길 공간)
- 사용자 영역(user space) : 사용자 응용 프로그램이 적재되는 공간, 사용자 응용 프로그램은 운영체제와 달라 CPU나 메모리와 같은 자원에 직접 접근 및 조작이 불가하기 때문에 운영체제가 대신 자원 접근 및 조작을 실행해준다고 볼 수 있다.
- 시스템 콜(system call) : 응용프로그램이 호출하여 운영체제의 코드를 실행하는 콜. 운영체제의 서비스를 제공받기 위한 수단(interface), 호출 가능한 함수의 형태로 되어 있으며 시스템 콜의 종류와 개수는 정말 다양하다. (fork, execve, exit, waitpid, open, close, read, write, chdir, mkdri, mount 등)
- 소프트웨어 인터럽트(software interrupt) : 운영체제의 명령어에 의해 발생하는 인터럽트
- 사용자 모드(user mode) : 사용자 영역에 적재된 코드를 실행할 때의 모드, 운영체제 서비스를 제공받을 수 없는 모드로 실수로라도 자원에 접근이 불가
- 커널 모드(kernel mode) : 커널 영역에 적재된 코드를 실행할 때의 실행 모드, 운영체제 서비스를 제공받을 수 있는 실행 모드로 자원에 접근이 가능
- 이중 모드(dual mode) : 2개의 모드로 구분하여 실행하는 모드

#### 프로세스 계층 구조
- 프로세스는 시스템 콜을 통해 또 다른 프로세스를 생성하고, 생성된 프로세스는 또 다른 프로세스를 실행할 수 있다. 새 프로세스를 생성한 프로세스를 부모 프로세스, 부모에 의해 생성된 프로세스를 자식 프로세스라고 한다.

## 프로세스와 스레드
---
- 포그라운드 프로세스(foreground process) : 사용자가 보는 공간에서 사용자와 상호작용하며 실행되는 프로세스
- 백그라운드 프로세스(background process) : 사용자가 보지 못하는 곳에서 실행되는 프로세스
- 데몬(daemon) : 사용자와 별다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스, 윈도우에선 서비스(service)라고 한다.
- 커널 영역에는 **프로세스 제어 블록(PCB)**라는 정보가 저장, 사용자 영역에는 실행 중인 프로세스가 **코드, 데이터, 힙, 스택**으로 나뉘어 저장

#### 코드 영역 (code segment)
- 실행 가능한 명령어가 저장, 텍스트 영역이라고도 한다. 읽기 전용 공간

#### 데이터 영역 (data segment)
- 프로그램 실행 동안 유지되어야 할 데이터가 저장되는 공간, 정적 변수나 전역 변수가 대표적인 데이터.

#### 힙 영역(heap segment)
- 사용자가 직접 할당 가능한 저장 공간이지만 공간이 할당되었다면 언젠간 반환을 해야 하는데, 반환이 되지 않으면 메모리 누수가 발생할 수 있으며 이를 해결하기 위한 가비지 컬렉션(garbage collection) 기능을 제공

#### 스택 영역(stack segment)
- 일시적으로 사용할 값들이 저장되는 곳으로 매개변수, 지역 변수, 함수 복귀 주소 등이 저장되는 대표적 데이터.
- 스택 트레이스(stack trace) : 특정 시점에 스택 영역에 저장된 함수 호출 정보로 문제의 발생 지점을 추적할 수 있어 디버깅에 매우 유용하게 사용된다 (Python에서는 Traceback이라는 메시지로 나오게 된다)

#### PCB와 문맥 교환
- 프로세스 제어 블록(Process Control Block) : 프로세스를 식별할 수 있는 커널 영역 내의 정보. 프로세스 ID(PID)와 레지스터 값, 프로세스 상태, CPU 스케줄링 정보, 메모리 관련 정보, 파일 및 입출력장치 관련 정보가 명시.
- 프로세스 테이블(process table) : 커널 내의 PCB가 관리되는 형태. PCB를 프로세스 테이블에 추가하여 필요한 자원들을 할당받는 방식으로, 프로세스가 종료되면 사용 중이던 자원을 해제하고 PCB도 프로세스 테이블에서 삭제
- 프로세스가 실행된다 = 운영체제에 의해 CPU의 자원을 할당받았다
- 타이머 인터럽트(timer interrupt) : 시간이 끝났음을 알리는 인터럽트로 CPU 사용 시간을 제한할 수 있는 인터럽트다. 타임아웃 인터럽트라고도 부르며 정해진 시간만큼 CPU를 사용하고 타이머 인터럽트가 발생하면 차례를 종료하고 다음 차례에 양보하는 방식.
- 프로세스가 종료되면 중간 정보를 백업하고 추후에 재개할 때 사용할 수 있는데, 이 때 기억하는 정보를 **문맥(context)**라고 한다. 즉 인터럽트가 발생하면 운영체제는 해당 프로세스의 PCB에 문맥을 백업하고 뒤이어 실행할 프로세스의 문맥을 복구하는데, 이를 문맥 교환(context switching)이라고 한다.
- 하지만 이런 문맥 교환이 너무 자주 발생하면 좋지 않은데, 캐시 미스가 발생할 수 있고 큰 오버헤드로 이어질 수 있기 때문이다.

#### 리눅스 (오픈 소스 운영체제)
- 리눅스(linux) : 운영체제의 소스 코드가 공개된 소프트웨어로 다양한 운영체제에 영향을 끼치고 오늘날 많은 서버 컴퓨터 환경에서 활용되는 소프트웨어이다.

#### 프로세스의 상태
- 생성 상태(new) : 프로세스를 생성중인 상태로 메모리에 적재되어 PCB를 할당받은 상태
- 준비 상태(ready) : 당장이라도 CPU를 할당받아 실행할 수 있지만, 기다리고 있는 상태. CPU를 할당받으면 실행 상태가 되며 이를 디스패치(dispatch)라고 한다
- 실행 상태(running) : CPU를 할당받아 실행 중인 상태, 일정 시간 동안만 사용 가능. 할당된 시간을 다 사용하면 준비 상태가 되며, 작업이 끝날때 까지 기다려야 한다면 대기 상태가 된다.
- 대기 상태(blocked) : 입출력 작업을 요청하거나 바로 확보할 수 없는 자원을 요청하는 등 곧장 실행이 불가능한 조건에 놓이는 경우. 입출력 작업을 요청하는 경우가 대표적이다.
- 종료 상태(terminated) : 프로세스가 종료된 상태로 메모리를 정리한다.

#### 블로킹 입출력과 논블로킹 입출력
- 블로킹 입출력(blocking I/O) : 입출력 작업이 수행되어야 하면 프로세스가 대기 상태로 접어든 후 입출력 작업이 완료되면 준비 상태가 되어 실행을 재개하는 방식
- 논블로킹 입출력(non-blocking I/O) : 모든 프로세스가 반드시 대기 상태에 접어들 필요 없이 입출력 작업 마무리 후 명령어를 실행하는 방식

### 멀티프로세스와 멀티스레드
---
- 같은 프로그램을 각기 다른 여러 프로세스로 생성하여 실행하는 방법으로, 인터넷의 탭이 하나 추가될 때마다 프로세스도 하나씩 추가 되는 방식처럼 여러 프로세스가 실행되는 것을 멀티프로세스(multi-process)라고 한다.
- 멀티프로세스에서 중요한 점은 자원을 공유하지 않고 독립적으로 실행된다는 것인데, 각각의 PID를 가지고 있으며 프로세스별로 파일과 입출력장치 등의 자원이 독립적으로 할당되어 다른 프로세스에 영향을 거의 끼치지 않는다는 것이다.
- 멀티스레드(multi-thread) : 프로세스를 동시에 실행하는 여러 스레드로, 한 스레드에는 스레드 ID, 프로그램 카운터, 레지스터 값, 스택 등으로 구성되어 있으며 스레드마다 실행할 주소를 가질 수 있고 연산 과정의 임시 저장 값을 가질 수 있다.
- **자원의 공유 여부** : 멀티프로세스는 자원을 공유하지 않지만 멀티스레드는 자원들을 공유한다. 스레드들은 동일한 주소 공간의 코드, 데이터, 힙 영역을 공유하며 쉽게 협력하고 통신할 수 있다는 장점이 있지만 한 스레드에 문제가 생기는 경우 프로세스 전체의 문제가 될 수 있다. 다양한 프로그래밍 언어(C, java, Python, Go 등)에서 스레드 생성과 관리를 지원한다.

#### 스레드 조인
- 스레드를 생성할 때는 join이라는 문구를 사용하는데, '생성/실행된 스레드가 종료될때까지 대기' 해야 한다. 각 스레드별로 실행 종료를 반복하면서 진행된다는 것이다.

### 프로세스간 통신
---
- 프로세스 간 통신(IPC, Inter-Process Communication) : 프로세스 간에도 자원을 공유하고 데이터를 주고 받을 수 있는 방법
- 공유 메모리 : 데이터를 주고받는 프로세스가 공통적으로 사용할 메모리 영역을 두는 방식
- 메시지 전달 : 프로세스 간에 주고받을 데이터를 메시지의 형태로 주고받는 방식

#### 공유 메모리(shared memory)
- 공유하는 메모리 영역을 토대로 데이터를 주고받는 통신 방식
- 프로세스는 기본적으로 자원을 공유하지 않으므로 임의로 수정할 수 없으나, 공유 메모리라는 특별한 메모리 공간을 할당하여 해당 메모리 공간을 공유하며 서로 읽고 쓸 수 있는 상태로 만들 수 있다는 것이다. 즉 프로세스가 공유하는 변수나 파일을 활용하여 프로세스 간의 통신을 주고 받을 수 있다는 것이다.
- 공유 메모리의 특징은 통신을 주고받는 프로세스가 마치 자신의 메모리 영역을 읽고 쓰는 것 처럼 통신하는 점인데, 이는 커널의 개입이 거의 없다는 것을 확인할 수 있다. 메시지 전달 방식보다 통신 속도가 빠르나 데이터의 일관성이 훼손될 수 있다. (**레이스 컨디션 발생 가능성**)

#### 메시지 전달
- 프로세스 간에 주고받을 데이터가 커널을 거쳐 송수신 되는 통신 방식
- 커널의 도움을 적극적으로 받을 수 있으므로 레이스 컨디션이나 동기화 등의 문제를 고려할 일이 상대적으로 적으나 메모리 기반 공유보다 통신 속도가 느리다는 단점이 있다.
- 메시지 전달 기반의 대표적 수단으로는 파이프, 시그널, 소켓, 원격 프로시저 호출 등이 있다.
- 파이프(pipe) : 단방향 프로세스 간의 통신 도구를 말하며 물길처럼 데이터가 흐를 수 있는 공간이라고 생각하면 쉽다. 읽기용 파이프와 쓰기용 파이르 2개를 이용하여 양방향으로 통신을 수행할수도 있다. 여기서 **익명 파이프**는 단방향 통신 수단이며 부모와 자식 프로세스 간에만 통신이 가능하며, **지명 파이프**는 양방향 통신을 지원하며 임의의 프로세스 간에도 통신을 사용할 수 있다.
- 시그널(signal) : 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기적 신호이다. SIGCHLD, SIGILL, SIGKILL, SIGTERM 등의 시그널 종류가 있다. 시그널이 발생하게 되면 하던 일을 잠시 중단하고 **시그널 핸들러**를 실행한 뒤 실행을 재개한다. 비동기적으로 원하는 동작을 수행할 수 있는 좋은 수단이라고 볼 수 있다.
- 코어 덤프(core dump) : 비정상적으로 종료하는 경우에 생성되는 파일로 특정 시점에 작업하던 메모리의 상태가 기록되어 있어 디버깅 용도로 자주 사용하게 될 파일이다.
- 원격 프로시저 호출(RPC) : 원격 코드를 실행하는 IPC 기술로, 프로그래밍 언어나 플랫폼과 무관하게 성능을 최소화하고 메시지 송수진이 가능하기 때문에 대규모 트래픽 처리 환경이나 서버 간 통신 환경에서 사용되는 경우가 많다. 대표적으로 구글의 gRPC가 있다.

## 동기화와 교착상태
---
- 공유 자원(shared resource) : 프로세스 혹은 스레드가 공유하는 자원. 다수의 프로세스 혹은 스레드가 동시에 공유 자원에 접근할 경우 실행에 문제가 있을 수 있는데, 이런 코드는 **임계 구역(critical section)** 이라고 한다. 예를 들어 프로세스가 반대로 실행이 되는 경우, 쓰이지 않은 메모리를 읽으려 하는 경우에 발생하는 문제가 있다고 했을 때 쓰는 코드와 읽는 코드는 서로의 임계 구역이 될 수 있다.
- 레이스 컨디션(race condition) : 동시에 임계 구역의 코드를 실행하여 문제가 발생하는 상황. 자원의 일관성이 손상될 수 있기 때문에 둘 중 하나는 작업을 끝내기까지 대기해야 한다.
- 동기화(synchronization) : 임계 구역을 관리하면서 동시에 레이스 컨디션을 방지할 수 있는 방법으로 실행 순서 제어, 상호 배제 2가지의 조건을 준수하며 실행해야 한다.

### 동기화 기법
---
- 동기화 기법은 많은 프로그래밍 언어에서 제공하고 있는 기능이다.

#### 뮤텍스 락 (mutex lock)
- 동시에 접근해서는 안 되는 자원에 동시 접근이 불가능하도록 상호 배제를 보장하는 동기화 도구로 임계 구역에 접근하고자 한다면 반드시 락을 획득해야 하고 작업이 끝났다면 락을 해제해야 한다는 원리를 따르고 있다.
- 변수(lock)와 2개의 함수(acquire, release)로 구성되어 있으며, 락을 획득(acquire)한 후에 실행이 되며 실행이 완료도니 후에 해제(release)를 통해 임계 구역을 열어주어야 하는데, acquire를 호출한다고 해서 반드시 락을 획득할 수 없으며 선행된 작업이 끝난 후에 얻을 수 있다는 점이 중요하다.
- Python, C/C++ 등의 프로그래밍 언어에서는 뮤텍스 락을 제공하며(pthread_mutex_t) 자바에서도 락을 지원(java.util.concurrent.locks.ReentrantLock)한다.

#### 세마포 (semaphore)
- 뮤텍스 락과 비슷하지만 조금 더 일반화된 방식의 동기화 도구로서 공유 자원이 여러 개 있는 상황에서도 동기화가 가능하며 '멈춤' 신호와 '가도 좋다'는 신호로 임계 구역을 관리한다.
- 변수 하나와 wait(), signal() 함수 2개로 구성되어 있으며 변수는 임계구역에 진입할 수 있는 프로세스의 개수와 같다. 임계 구역 진입 전후로 wait()와 signal() 함수로 호출하여 사용.
- wait() 호출 시 변수를 1 감소시키고 변수의 값이 0보다 작은지 여부를 확인하고 0보다 작으면 wait()을 호출한 프로세스 및 스레드는 대기 상태로 돌입한다.
- signal() 함수를 호출하면 변수를 1 증가시키고 변수의 값이 0 이하인지를 확인하며, 0이하인 경우에는 대기 프로세스가 존재한다는 뜻이다. 대기 상태로 접어든 프로세스 중 하나를 준비 상태로 전환한다.
- 세마포도 여러 프로그래밍 언어에서 지원하며 java는 java.util.concurrent.Semaphore로 지원하고 C++에서는 semaphore.h를 include하면 사용할 수 있다.
- 이진 세마포(binary semaphore) : 변수가 0과 1의 값을 가지는 세마포로 뮤텍스 락과 유사하게 동작
- 카운팅 세마포(counting semaphore) : 위에 설명했던 개념과 같은 세마포로 하나씩 카운팅하면서 작동하는 세마포라고 볼 수 있다.

#### 조건 변수와 모니터
- 조건 변수(condition variable) : 실행 순서 제어를 위한 동기화 도구, 특정 조건 하에 프로세스를 실행/일시 중단함으로써 프로세스나 스레드의 실행 순서를 제어할 수 있다. wait()함수를 통해 호출한 프로세스 및 스레드의 상태를 대기 상태로 전환하고, signal() 함수로 일시 중지된 프로세스 및 스레드의 실행을 재개할 수 있다.
- 모니터(monitor) : 공유 자원과 그 공유 자원을 다루는 함수(인터페이스)로 구성된 동기화 도구로 프로세스 및 스레드는 공유 자원에 접근하기 위해 반드시 정해진 공유 자원 연산(interface)을 통해 모니터 래놀 진입해야 하고 모니터 안에 진입하여 실행되는 프로세스 및 스레드는 항상 하나여야 하기 때문에 이미 실행중이라면 큐에서 대기해야 한다.

#### 큐 (queue)
- 먼저 삽입된 데이터를 먼저 활용할 수 있는 선입선출(FIFO, First-In-First-Out) 구조의 데이터를 의미한다. 줄 끝에 서는 것을 마지막에 삽입하고, 줄 앞에서 빠져나가는 것을 큐에서 빼낸다고 이해할 수 있다.
- 프로세스 A가 프로세스 B보다 먼저 실행되어야 한다라고 할 때 프로세스 B가 A가 실행되지 않았는데 진입한다면 wait()를 호출하여 대기 상태로 만들어버릴 수 있기 때문에 반드시 프로세스 A, 그 다음 프로세스 B의 순으로 실행되게 할 수 있는 실행 순서 제어를 위한 동기화가 이루어진다고 볼 수 있다. 대표적으로 java의 synchronized 키워드를 예시로 들 수 있다.

#### 스레드 안전 (thread safety)
- 멀티스레드 환경에서 어떤 변수나 함수, 객체에 동시 접근이 이루어져도 실행에 문제가 없는 상태를 의미한다. 어떤 스레드에 의해 호출되어도 레이스 컨디션이 발생하지 않는다는 의미와 같다고 볼 수 있다.
- synchronized 메서드로 구현되어 있으면 여러 스레드가 실행되어도 안전을 보장할 수 있다고 볼 수 있다.

### 교착 상태
---
- 교착 상태(deadlock) : 일어나지 않을 사건을 기다리며 프로세스의 진행이 멈춰 버리는 현상을 의미한다.

#### 교착 상태의 발생 조건
- 교착 상태의 상황에서는 4가지의 필요 조건이 있는데 상호 배제, 점유와 대기, 비선점, 원형 대기 총 4가지이다. 4개의 조건이 모두 만족할 때 교착 상태가 발생할 가능성이 생긴다고 볼 수 있다.
- 조건 1. 상호 배제 : 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태
- 조건 2. 점유와 대기 : 어떤 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다린다면 교착 상태에 발생할 수 있다.
- 조건 3. 비선점 : 해당 자원을 이용하는 프로세스의 작업이 끝나야만 비로소 자원을 이용할 수 있다는 것. 자원을 강제로 빼앗지 못하는 경우 교착 상태가 발생할 수 있다는 것이다.
- 조건 4. 원형 대기 : 프로세스와 프로세스가 요청한 자원이 원의 형태를 이루는 경우

#### 교착 상태의 해결 방법
- 교착 상태 예방 : 교착 상태를 발생시키는 4가지 필요 조건 중 하나를 충족하지 못하게 하는 방법. 프로세스에 필요한 자원들을 몰아준다거나 모든 자원에 번호를 매기고 오름차순으로 할당하는 경우하면 원형 대기 조건을 방지할 수 있다.
- 교착 상태 회피 : 교착 상태가 발생하지 않을 정도로만 조심하면서 자원을 할당하는 방법으로 한정된 자원의 무분별한 할당으로 인해 발생하는 문제를 교착 상태로 간주하여 이를 피하려고 하는 방법
- 교착 상태 검출 후 회복 : 교착 상태의 발생을 인정하고 처리하는 사후 조치로 그때 그때 자원을 할당하고 주기적으로 교착 상태의 발생 여부를 검사하여 프로세스를 자원 선점을 통해 회복시키거나 교착 상태에 놓인 프로세스를 강제 종료함으로써 회복하는 방법.

## CPU 스케줄링
---
- CPU의 사용을 배분함으로써 CPU의 자원을 관리하는 방법
- CPU 스케줄링 알고리즘 : CPU 스케줄링의 절차
- CPU 스케줄러(CPU scheduler) : CPU 스케줄링 알고리즘을 결정하고 수행하는 운영체제의 일부분

#### 우선순위
- 프로세스별 우선순위를 판단하여 PCB에 명시하고, 우선순위가 높은 프로세스는 CPU의 자원을 더 빨리, 더 많이 할당하는 방식.
- CPU 활용률(CPU utilization) : 우선순위를 고려하는 대표 요소로 전체 CPU의 가동 시간 중 작업을 처리하는 시간의 비율을 의미
- CPU 버스트(CPU burst) : CPU와 입출력장치를 모두 사용해 실행과 대기 상태를 오가며 실행되는 작업들을 의미하며, 입출력장치를 기다리는 작업은 입출력 버스트(I/O burst)라고 한다.
- 입출력 집중 프로세스 : 입출력 작업이 많은 프로세스를 처리하는 것, 입출력을 위한 대기 상태에 더 많이 머무른다.
- CPU 집중 프로세스 : 복잡한 수학 연산이나 그래픽 처리 작업을 담당하는 프로세스, 대기 상태보다 실행 상태에 더 많이 머무른다.
- 입출력 집중 프로세스를 가능한 빨리 실행시켜 끊임없이 입출력장치를 작동시킨 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 합리적.

#### 스케줄링 큐 (scheduling queue)
- 운영체제는 프로세스들에게 자원을 이용하고 싶다면 줄을 서서 기다릴 것을 요구하는 것을 스케줄링 큐를 통해 구현하게 되는데, 프로세스의 PCB나 특정 입출력장치를 이용하고 싶은 프로세스의 PCB를 큐에 삽입하는 방식으로 진행된다.
- 준비 큐(ready queue) : CPU를 이용하고 싶은 프로세스의 PCB가 서는 줄을 의미
- 대기 큐(waiting queue) : 대기 상태에 접어든 프로세스의 PCB가 서는 줄을 의미하는데, 입출력 작업을 수행 중일 경우 대기 큐에서 대기 상태로 입출력 완료 인터럽트를 기다리게 되며, 마지막에 삽입되며 CPU를 사용할 차례를 기다리는 방식이다.
- 같은 입출력장치를 요구한 프로세스들은 같은 대기 큐에서 기다리며, 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 큐에서 제거되는 것 처럼 여러 프로세스들을 효율적으로 관리할 수 있다.

#### 선점형 스케줄링과 비선점형 스케줄링
- 스케줄링은 기본적으로 프로세스의 시행이 끝나면 이루어지는데, 프로세스가 종료되지 않았음에도 실행 도중 스케줄링이 수행되는 시점도 있다. 실행 상태에서 입출력 작업을 위해 대기 상태로 전환하거나 실행 상태에서 타이머 인터럽트가 발생해 준비 상태로 변경될 때이다.
- 선점형 스케줄링(preemptive scheduling) : 운영체제가 프로세스로부터 CPU 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링, 타이머 인터럽트 기반의 스케줄링은 모두 선점형 스케줄링의 일종이라고 볼 수 있다. 한 프로세스의 CPU 독점을 막고 여러 프로세스에 골고루 CPU를 분배할 수 있는 장점이 있지만, 문맥 교환 과정에서 오버헤드가 발생할 수 있음.
- 비선점형 스케줄링(non-preemptive scheduling) : CPU를 사용하고 있을 때 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지는 다른 프로세스가 끼어들 수 없는 스케줄링 방식으로 다른 프로세스들은 그 프로세스의 CPU 사용이 모두 끝날때까지 기다려야 한다. 문맥 교환 횟수가 상대적으로 적기 때문에 오버헤드의 발생은 적지만 당장 CPU를 사용해야 하는 프로세스라도 무작정 기다리는 수밖에 없다는 단점이 있다.

### CPU 스케줄링 알고리즘
---
- 7가지 CPU 스케줄링 알고리즘이 존재한다.

#### 선입 선처리 스케줄링 (FCFS, First Come First Served)
- 준비 큐에 삽입된 순서대로 먼저 CPU를 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식이다. 프로세스들이 기다리는 시간이 매우 길수도 있는 문제와 나중에 삽입된 프로세스의 실행이 지연되는 문제(호위 효과)가 발생할 수 있다.

#### 최단 작업 우선 스케줄링 (SJF, Shortest Job First)
- CPU를 이용하는 시간의 길이가 가장 짧은 프로세스부터 먼저 실행하는 스케줄링 방식으로 비선점형 스케줄링 알고리즘으로 분류되지만 선점형으로 구현 가능하다,.

#### 라운드 로빈 스케줄링 (round robin)
- 선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식으로 선점형 스케줄링이고, 타임 슬라이스 내에 완료되지 않으면 문맥 교환이 발생해 다시 큐의 맨 뒤에 삽입될 수도 있다.
- 타임 슬라이스(time slice) : 프로세스가 CPU를 사용하도록 정해진 시간을 의미하며, 정해진 타임 슬라이스만큼 CPU를 이용할 수 있다.

#### 최소 잔여 시간 우선 스케줄링 (SRT, Shortest Remaining Time)
- 최단 작업 우선 스케줄링과 라운드 로빈 스케줄링 방식으로 정해진 타임 슬라이스만큼 CPU를 이용하되 남아 있는 작업시간이 가장 적은 프로세스를 다음으로 CPU를 이용할 프로세스로 선택

#### 우선순위 스케줄링
- 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식이지만 아주 근본적인 문제를 내포하고 이는데 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스로 인해 계속해서 실행이 연기될 수 있다.
- 아사(starvation) : 우선순위가 낮은 프로세스가 계속해서 실행이 연기되는 현상, 이를 방지하기 위한 에이징(aging) 기법이 있다. 에이징은 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식.

#### 다단계 큐 스케줄링
- 우선순위 스케줄링의 발전된 형태로, 여러 개의 준비 큐를 사용하는 스케줄링 방식. 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있게 되면 그 다음으로 우선순위가 높은 큐에 있는 프로세스를 처리한다.
- 프로세스들이 큐 사이를 이동할 수 없기 때문에 우선순위가 낮은 프로세스의 작업이 계속해서 연기될 수 있다. 아사 현상이 발생할 수 있으며, 이를 보완하는 스케줄링 알고리즘이 다단계 피드백 큐 스케줄링이다.

#### 다단계 피드백 큐 스케줄링
- 다단계 큐 스케줄링과 비슷하게 동작하지만 프로세스들이 큐 사이를 이동할 수 있다는 점에서 차이가 있다.
- 새롭게 진입하는 프로세스는 먼저 우선순위가 가장 높은 우선순위 큐에 삽입되고 타임 슬라이스 동안 실행되며, 실행이 끝나지 않으면 다음 우선순위 큐에 삽입되어 실행된다. 결국 CPU를 오래 사용해야 하는 CPU 집중 프로세스들의 우선순위는 낮아지고, 입출력 집중 프로세스들은 우선순위가 높은 큐에서 실행이 끝나게 된다. 아사 현상을 예방하기 위해 낮은 우선순위 큐에서 오래 기다리고 있는 프로세스들은 높은 우선순위 큐로 이동시키는 에이징 기법을 적용할 수 있다.

### 리눅스 CPU 스케줄링
---
- 스케줄링 정책(scheduling policy) : 새로운 프로세스를 언제 어떻게 선택하여 실행할지를 결정하기 위한 규칙의 집합 (SCHED_FIFO, RR, NORMAL, BATCH, IDLE)
- SCHED_FIFO, SCHED_RR : RT(Real-Time) 스케줄러에 의해 이뤄지는 스케줄링으로 실시간 프로세스에 적용되는 스케줄링 정책
- SCHED_NORMAL : CFS라는 CPU 스케줄러에 의해 스케줄링이 이뤄지며, CFS(Completely Fair Scheduler)란 완전히 공평한 CPU 시간 배분을 의미한다.
- 리눅스에서는 프로세스마다 가상 실행 시간(virtual runtime)이라는 정보를 유지하는데, CFS는 이 vruntime이 가장 작은 프로세스부터 스케줄링한다.
- vruntime : 프로세스의 가중치를 고려한 가상의 실행 시간으로 프로세스의 가중치가 높을수록 먼저 스케줄링될 확률이 높다. 프로세스의 우선순위가 높아질수록 가중치도 늘어나며 리눅스 운영체제에서 '/proc/<PID>/sched'라는 파일을 출력하는 명령어를 통해 확인할 수 있다. (cat /proc/<PID>/sched)
- vruntime 최솟값 빠르게 골라내는 방법에는 **RB 트리** 자료구조를 활용하는데, 이 자료구조는 여러 값 중 최솟값과 최댓값을 빠르고 효율적으로 찾아낼 수 있는 자료구조의 일종이다.