# Chapter 02. 컴퓨터 구조 (Computer Architecture)
---
## 목차
---
1. [컴퓨터 구조](#컴퓨터-구조)
- [컴퓨터 이해 정보](#컴퓨터-이해-정보)
- [컴퓨터 핵심 부품](#컴퓨터-핵심-부품)
2. [컴퓨터 이해 정보](#컴퓨터-이해-정보)
- [데이터 숫자 표현](#데이터-숫자-표현)
- [데이터 문자 표현](#데이터-문자-표현)
- [명령어](#명령어)
3. [CPU](#CPU)
- [레지스터](#레지스터)
- [인터럽트](#인터럽트)
- [CPU 성능 향상 설계법](#CPU-성능-향상-설계법)
- [파이프라이닝](#파이프라이닝)
4. [메모리](#메모리)
- [RAM](#RAM)
- [엔디안](#엔디안)
- [캐시 메모리](#캐시-메모리)
5. [보조기억장치와 입출력장치](#보조기억장치와-입출력장치)
- [RAID](#RAID)
- [입출력 기법](#입출력-기법)
- [별첨 GPU의 용도와 처리 방식](#GPU의-용도와-처리-방식)

## 컴퓨터 구조
---
- 컴퓨터가 이해하는 정보, 하드웨어적 부품에 대해서 살펴본다.
- 0과 1로 이루어진 데이터가 명령어에 의해서 어떻게 실행이 되고, 핵심 부품들의 역할과 작동 방법에 대해 알아보며 개념을 정립해 나갈 수 있다.

### 컴퓨터 이해 정보
---
- 컴퓨터는 java, C++, Python과 같은 프로그래밍 언어를 직접적으로 이해할 수 없다. 컴퓨터는 데이터와 명령어를 통해 이해를 수행하며, 작성한 코드는 데이터와 명령어의 형태로 변환된 뒤에 실행된다. 컴퓨터의 명령어는 **수행할 동작**과 **수행할 대상**으로 이루어져 있다.
- 데이터 : 숫자, 문자, 이미지, 동영상과 같은 정적인 정보, 컴퓨터와 주고받는 정보 또는 저장된 정보 자체를 데이터라고 통칭해서 부르기도 한다. 데이터는 명령어에 종속적인 정보이며, 명령의 대상이자 명령어의 재료라고 할 수 있다.
- 데이터와 명령어는 컴퓨터가 이해할 수 있는 언어인 **0과 1**로 이루어져 있다. CPU는 명령어를 이해하고 실행하는 주체인데, 이 말은 CPU의 종류에 따라 실행 가능한 세부적인 명령어의 종류와 처리 양상이 달라질 수 있다는 것이다. 이러한 명령어는 CPU 내부에서 순차적으로 실행이 되며, 이를 처리할 수 있도록 **명령어 사이클**이 존재한다.

### 컴퓨터 핵심 부품
---
- 컴퓨터의 핵심 부품은 CPU(중앙처리장치), 메모리(주기억장치), 캐시 메모리, 보조기억장치, 입출력장치 등 여러 부품들로 구성되어 있다.

#### CPU
- CPU (Central Processing Unit) : 정보를 읽어 들이고, 해석하고, 실행하는 부품으로 사람으로 비유했을 때 두뇌에 해당하는 부품
- 산술논리연산장치 (ALU, Arimetic and Logic Unit) : 사칙 연산, 논리 연산과 같은 연산을 수행할 수 있는 회로로 구성되어 있는 계산기를 담당하는 장치. CPU가 처리할 명령어를 실질적으로 연산할 수 있는 요소라고 볼 수 있다.
- 제어장치 (CU, Control Unit) : 명령어를 해석해 제어 신호라는 전기적 신호를 내보내는 장치. 제어 신호는 부품을 작동시키기 위한 신호를 의미하며, 메모리에 전달하면 메모리를 작동할 수 있고 입출력장치에 전달하면 입출력장치를 작동시킬 수 있다.
- 레지스터(register) : CPU 내부의 작은 임시 저장장치로 데이터와 명령어를 처리할 때 발생하는 중간값을 저장하며, 여러 개의 레지스터를 가지고 있다. 이 레지스터들은 각각 다른 이름과 역할을 가지고 있다. CPU가 처리하는 명령어가 반드시 레지스터에 저장이 되기 때문에 레지스터 값만 관찰을 잘 해도 프로그램의 실행 과정을 low-level에서부터 파악할 수 있다.

#### 메모리와 캐시 메모리
- 메모리 = 메인 메모리 (main memory) : 주 기억장치로써 RAM과 ROM이 있고, 주로 RAM을 지칭하는 경우가 많다. CPU가 **실행중인** 프로그램을 구성하는 데이터와 명령어 등 다양한 정보를 저장하는 부품이다.
- 메모리와 관련해서 중요한 개념들에는 **주소**라는 개념과 **휘발성**이라는 개념이 있다.
- 주소 (address) : CPU가 원하는 정보로 접근할 수 있도록 데이터와 명령어를 정돈되게 저장해놓을 수 있는 공간
- 휘발성 (volatile) : 전원이 공급되지 않을 때 저장하고 있는 정보가 지워지는 특성이다. 메모리는 휘발성 저장장치로 전원이 꺼지면 모두 삭제된다.
- 캐시 메모리 (cache memory) : CPU가 조금이라도 더 빠르게 메모리에 저장된 값을 접근할 수 있도록 사용되는 저장장치. 메모리 접근을 보조할 수 잇는 보조 저장장치라고 볼 수 있다. 위치는 CPU 내부 또는 CPU 외부에 존재할 수 있다.

#### 보조기억장치
- 메모리는 휘발성 저장장치이기 때문에 저장된 정보를 모두 삭제하게 되는데, 이는 오랫동안 컴퓨터를 사용하는데에 문제가 될 수 있다. 이를 보조하기 위해 보조기억장치를 활용한다.
- 보조기억장치 (secondary storage) : 저장된 정보가 사라지지 않는 **비휘발성** 저장장치이다. 종류로는 CD-ROM, DVD, HDD, SSD, USB, 플로피 디스크 등 여러가지 저장장치가 존재한다. 메모리가 현재 실행중인 프로그램의 정보에 대해 저장한다면, 보조기억장치는 보관할 프로그램을 저장한다고 할 수 있다. CPU가 보조기억장치에 저장된 프로그램을 실행할 때 메모리로 복사할 수 있는데, 이를 안전하고 안정적으로 구상할 수 있도록 하는 기술인 **RAID** 기술이 있다.

#### 입출력장치
- 입출력장치 (input/output device) : 컴퓨터 외부에 연결이 되어 컴퓨터 내부와 정보를 교환할 수 있는 장치. 입력 장치로는 마우스, 키보드, 마이크 등이 있고 출력 장치로는 스피커, 모니터, 프린터 등이 있다. 보조기억장치는 메모리를 보조하는 임무를 가진 특별한 입출력장치라고 볼 수 있다. usb와 같이 외부에 꽂아 내부의 정보를 받아올 수 있는 그러한 장치들도 존재하기 때문이다. 이러한 특성으로 보조기억장치와 입출력장치를 통틀어 주변 장치 (peripheral device)라고도 한다.

#### 메인보드와 버스
- 메인 보드 (main board, mother board) : 부품들은 공중에 떠있지 않으며 어딘가에 고정되어 있다. 이렇게 부품들을 고정하고 연결하는 기관을 메인 보드라고 한다. 여러 부품들을 장착할 수 있는 슬롯과 연결 단자들이 존재하며, 컴퓨터 내부를 보면 커다란 기판이 있는데 이를 메인 보드라고 한다.
- 버스 (bus) : 각 컴퓨터 부품들이 주고받는 통로. 버스는 여러가지 종류가 있지만 핵심 부품들을 연결하는 시스템 버스(system bus)가 중요한 요소라고 볼 수 있다.

#### 저장장치의 계층 구조
- CPU와 가까운 저장장치는 빠르고, 멀리 있는 저장장치는 느린 특성을 가지고 있다.
- 속도가 빠른 저장장치는 용량이 작고 가격이 비싼 단점이 있다.
- CPU와 가까운 순으로 나열하면 '레지스터 → 캐시 메모리 → 메모리 → 보조기억장치' 순으로 나열되어 있으며, 이를 저장장치 계층구조라고 한다.
- 이러한 장치들을 포함해 여러 캐시 메모리를 같이 더하면 세부적인 계층 구조를 만들어낼 수 있다.

## 컴퓨터 이해 정보
---
- CPU는 기본적으로 0과 1만을 이해하는데, 여기서 가장 작은 정보의 단위를 비트(bit)라고 한다. 1비트는 0 또는 1 2개의 정보 표현, 2비트는 4개의 정보, 3비트는 8개의 정보를 표현할 수 있다. 이로 보아 N비트는 $2^N$개의 정보를 표현할 수 있다.
- 비트는 너무 작은 단위이고, 프로그램의 크기를 표현할 때는 이보다 큰 표현인 바이트(byte), 킬로바이트(kB), 메가바이트(MB), 기가바이트(GB), 테라바이트(TB) 등 여러 단위로 불러서 사용하고 있다. 여기서 바이트는 8비트를 묶은 단위로 하나의 단위로 표현할 수 있는 정보는 $2^8$=256개를 표현할 수 있다. 각 단위가 바뀔 때 마다 이전 단위의 1,000개를 묶은 단위를 말한다. 다만 **kiB, MiB, GiB, TiB**의 단위는 이전 단위의 1,024개를 묶은 단위를 표현하는 차이점이 있다.
- 워드 (word) : CPU가 한 번에 처리할 수 있는 데이터의 크기를 의미하며, 프로그램의 크기가 4GB라도 CPU가 한 번에 4GB를 읽어 처리하는 방식이 아니다. 프로그램을 word 단위로 불러와서 읽어 들이고 처리하는데, 이 크기는 CPU의 크기에 따라 다르다. 현대 컴퓨터의 대부분 워드 크기는 32비트, 혹은 64비트이다.

### 데이터 숫자 표현
---
- 0과 1만을 이해할 수 있는 CPU의 특성상 컴퓨터 내부에서 **2진법**을 사용하여 2 이상, 0 이하의 수를 이해한다. 숫자 1을 넘어가는 시점에 0과 1, 2개의 숫자만을 활용하여 모든 수를 표현한다. 2진수로 표현된 수는 숫자 뒤에 아래 점자로 (2)를 붙이거나 2진수 앞에 0b를 붙인다.
- **16진법** : 2진법의 단점은 숫자를 표현할 때 길이가 너무 길다는 점이다. 10진수 숫자인 128을 2진수로 표현하면 '10000000(2)'와 같이 8자리의 숫자가 필요하다는 점이다. 이를 보완하기 위해 사용되는 방법이 16진수를 함께 사용하는 16진법이 있다. 16진법(hexadecimal)은 숫자 15를 넘어가는 시점에 자리올림을 통해 숫자를 표현하는 방법이다. 10, 11, 12, 13, 14, 15는 A, B, C, D, E, F로 표기한다. 16진수를 사용하는 곳은 MAC 주소 또는 IPv6와 같은 주소에서 사용한다.
- 컴퓨터의 소수 표현 시 표현하고자 하는 소수와 실제로 저장된 소수 간에 오차가 존재할 수 있다는 점이 있다는 것을 명심해야 한다. 그 이유는 컴퓨터 내부에서 소수를 표현할 때 대표적인 방식으로 **부동 소수점(floating point)** 방식을 이용하는데, 이 방식은 정밀도에 한계가 있기 때문이다.
- **부동 소수점** : 소수점이 고정되어 있지 않은 소수 표현 방식으로 소수점의 위치가 이동할 수 있고 유동적(floating)이라는 의미를 가지고 있다. 1.23123 * $10^2$와 같은 수가 있다고 할 때 2를 가수, 1.23123을 가수라고 표현할 수 있다. 107.6640625라는 10진수 소수가 있다고 할 때 1.101011101010101 * $2^6$으로 표현할 수 있고, 110101110.10101 * $2^-2$로 표현할 수 있다. 이 경우 지수는 6과 -2이고 지수가 양수인 경우 소수점을 왼쪽으로 이동한 횟수, 음수인 경우 소수점을 오른쪽으로 이동한 횟수라고 볼 수 있다.
- 최근에 지수와 가수를 이런 방식으로 표현하고 있다. 여기서 부호의 비트가 0이면 양수, 1이면 음수를 의미한다. 여기서 가수의 정수부에는 1로 통일된 정규화 수가 저장되는데, 이는 1.xxx의 형태로 표현되곤 한다. 그럼 저장 시에는 $2^지수$ * 1.xxx의 형태를 저장하여 지수의 값과 소수 부분만 저장하면 되는 것이다. ![alt text](image.png)
- 컴퓨터에 지수를 저장할 때에는 지수 값이 기본적으로 그대로 저장되는 방식이 아닌 바이어스(bias) 값이 저장되며, 이때 바이어스 값은 비트에 따라 다르다. 가령 8비트인 경우 $2^7$-1의 값인 127이, 11비트의 경우 $2^10$-1의 값인 1,023이 저장되는 것이다.
- 10진수 소수를 2진수로 표현할 때, 10진수 소수와 2진수 소수 표현이 딱 맞아 떨어지지 않을 수도 있다. 예를 들어 1/3이라는 분수를 2진수로 표현할 때는 1 x $3^-1$로 표현하면 되나, 10진수로 표현할 때는 0.333333... 과 같은 무수히 많은 소수점이 필요한 경우가 발생한다. 이와 같이 무수히 많은 소수점을 저장하기에는 컴퓨터의 저장공간이 충분하지 않다. 그래서 일부 소수점을 생략하여 저장하는데, 이러한 문제로 인해 표현하고자 하는 소수와 실제 저장된 소수 간에 오차가 발생하는 것이다.

### 데이터 문자 표현
---
- 문자 집합(character set) : 컴퓨터가 이해할 수 있는 문자들의 집합을 문자 집합이라고 하는데, 문자를 컴퓨터가 이해할 수 있는 0과 1의 코드로 변환하는 과정을 **문자 인코딩(character encoding)**이라고 하며, 0과 1로 표현된 문자를 사람이 이해하는 문자로 변환하는 과정을 **문자 디코딩(character decoding)**이라고 한다. 만약 웹페이지에서 문자가 깨져서 보인다면 특정 인코딩 방법을 지원하지 않거나, 디코딩을 하는 방법을 알지 못해 발생하는 결과라고 볼 수 있다.
- 아스키(ASCII) : 가장 기본적인 문자 집합이며 영어의 알파벳과 아라비아 숫자, 일부 특수 문자를 포함한다. 하나의 아스키 문자로 표현할 때는 8비트가 사용되는데, 이 8비트 중 1비트는 **패리티 비트**라고 부르며, 이는 오류 검출을 위해 사용되는 비트이기 때문에 7비트가 실질적 문자 표현에 사용되며 총 $2^7$(128)개의 정보를 표현할 수 있다. 아스키 문자들은 0부터 127까지의 숫자 중 하나의 고유한 수에 대응되며, 이를 **아스키 코드**라고 한다. [아스키 코드표](https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C)
- EUC-KR : 아스키 코드는 한글을 표현할 수 없는 단점을 극복하기 위해 만들어진 한글 인코딩 방식. KS X 1001, KS X 1003이라는 문자 집합 기반의 인코딩 방식으로 문자를 표현할 때는 1바이트, 한글을 표현할 때는 2바이트 크기의 코드를 부여한다. 2바이트는 네 자리 16진수로 표현할 수 있으며, 총 2,350개 정도의 한글 단어를 표현할 수 있다. 하지만 모든 한글 조합을 표현할 수 있을 정도로 많은 양을 표현하지는 않는다.
- 유니코드(unicode) : 모든 한글 조합을 표현할 수 없는 EUC-KR의 단점을 극복하기 위해 만들어진 문자 집합이며 훨씬 많은 언어, 특수문자, 화살표, 이모티콘까지 표현할 수 있는 통일된 문자 집합이다. 현대 가장 많이 사용되는 표준 문자 값이며, 문자 인코딩에 있어 매우 중요한 역할을 맡고 있다. 유니코드 문자 집합 속에 속한 문자에는 고유한 값 (0xD55C, 0xAE00)이다.
- 아스키 코드나 EUC-KR은 글자에 부여된 값을 그대로 인코딩 값으로 삼았지만, 유니코드는 글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고, 다양한 방법으로 인코딩을 하는데 이러한 기법에는 UTF-8, UTF-16, UTF-32와 같은 종류들이 있다. 이러한 인코딩 기법들은 **가변 길이 인코딩** 방식을 따르고 있고, 이는 인코딩된 결과의 길이가 일정하지 않을 수 있다는 것이다.
- base64 인코딩 : 문자 뿐만 아니라, 이진 데이터까지 변환할 수 있는 인코딩 방식. 이미지 등 단순 문자 이외의 데이터까지 모두 아스키 문자 형태로 표현할 수 있다. 실제로 이메일의 원문을 확인해보면 base64 기반으로 인코딩 되어 있는 것을 확인할 수 있다. base64는 64진법을 의미하며, 변환할 데이터를 6비트씩 나누어 하나의 문자로 표현하는데, 기본적으로 4개(24비트)씩 한 번에 변환된다. [base64-코드표](https://fl0ckfl0ck.tistory.com/32)
- base64로 나누어 떨어지지 않는 문자열이 있는 경우 비어있는 자리는 0으로 채워지게 되며, 이를 **패딩**이라고 한다. 패딩의 값은 0이며, 이는 '='로 인코딩이 되는 특성을 가지고 있다. 짧은 문자열도 패딩을 통해 base64 인코딩이 가능하다는 것을 알 수 있다.

### 명령어
---
- 명령어는 수행할 동작과 수행할 대상으로 이루어져 있다. 여기서 수행할 대상은 데이터 자체가 될 수 있고, 데이터가 저장된 위치가 될 수 있다. '명령어가 수행할 동작'은 연산 코드(opcode)라고 하고, '동작에 사용될 데이터 또는 데이터 저장 위치'를 오퍼랜드(operand)라고 한다. 하나의 명령어는 연산 코드와 0개 이상의 오퍼랜드로 구성.
- 오퍼랜드 : 오퍼랜드에는 대부분의 경우 연산 코드에 사용될 데이터가 저장된 위치 (= 레지스터 이름 or 메모리 주소)가 명시된다는 점이다. 오퍼랜드 필드 = 주소 필드(address field). 주어진 메모리 주소를 통해 메모리에 접근하여 명령어를 실행해야 한다.
- 연산 코드 : 연산 코드는 매우 다양하며, 대표적인 유형에는 데이터 전송(MOVE, STORE, LOAD, PUSH, POP), 산술/논리 연산(사칙연산, INCREMENT, AND/OR/NOT, COMPARE), 제어 흐름 변경(JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN), 입출력 제어(READ, WRITE, START IO, TEST IO)가 있다.
- 스택 : PUSH, POP 명령어는 스택에 대한 연산이며, 스택이란 한 쪽 끝이 막혀있는 통과 같은 형태로 데이터를 관리하는 자료구조를 의미한다. 데이터를 저장할 때는 막혀있지 않은 쪽으로 순차적으로 저장하며, 빼낼때는 마지막에 저장한 데이터부터 빼내서 관리하기 때문에 후입선출 (LIFO, Last In First Out) 자료구조라고도 부른다.

#### 기계어와 어셈블리어
- 기계어(machine code) : CPU가 이해할 수 있도록 0과 1로 표현된 정보를 있는 그대로 표현한 언어. 0111111010010001 과 같은 구조로 되어 있다.
- 어셈블리어(assembly language) : 0과 1로 표현된 기계어를 읽기 편한 형태로 단순 번역한 언어. 예를 들자면, 0101 0101은 push rbp와 같은 어셈블리어로 변환되며, 이를 통해 CPU가 이해할 수 있는 명령어의 종류와 동작들을 파악할 수 있다. 구체적인 연산 코드의 종류나 레지스터 이름, 명령어의 생김새가 CPU마다 다를 수 있다는 점을 알아두어야 한다. 이 때문에 명령어의 종류와 생김새가 다르면 기계어가 달라지고, 기계어가 달라지면 이를 번역한 어셈블리어도 달라진다. (CISC 기반, RISC 기반의 CPU로 분리된다.)
- 인텔 CPU에서 만들어진 실행 파일을 M1 칩을 사용하는 애플 CPU에서 실행하려고 하면, 실행할 수 없다. 이 때문에 특정 CPU에만 국한되는 의존적인 코드를 만들면 제한적인 프로그램으로 되기 때문에 좋은 프로그램이 아니게 된다. 범용적인 프로그램을 만드는 것이 중요하다.

#### 명령어 사이클
- 명령어 사이클(instruction cycle) : 메모리에서 명령어를 인출하고 실행하기를 반복하며 프로그램을 실행해나가는 정형화된 흐름을 말한다. 일정한 주기를 반복하면서 실행하는 특징이 있다.
- 인출 사이클(fetch cycle) : 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- 실행 사이클(execution cycle) : CPU로 가져온 명령어를 실행하는 단계
- 인출 사이클과 실행 사이클을 순환하면서 실행하는 사이클을 명령어 사이클이라고 한다. 명령어는 인출했더라도 곧바로 실행할 수 없는데, 오퍼랜드 필드에 메모리 주소가 명시된 경우 메모리에 한번 더 접근하는 사이클이 필요하다. 이러한 사이클을 **간접 사이클(Indirect cycle)**이라고 한다. 메모리 접근이 필요하거나 메모리 주소가 명시된 경우 간접 사이클을 통한 실행 사이클을 수행한다.
- 인터럽트 사이클(interrupt cycle) : 인터럽트를 처리하는 사이클로, 인터럽트가 발생하면 해당 인터럽트를 먼저 처리하는 사이클이다.

## CPU
---
- 컴퓨터에서 가장 중요한 부품 중 하나를 꼽으라고 한다면 단연 CPU를 곱을 것이다.

### 레지스터
---
- 레지스터(register) : CPU 내부에 있는 작은 임시 저장 장치로 다양한 레지스터가 존재하며, 각기 다른 이름과 역할을 가지고 있다. 레지스터의 값만 잘 관찰해도 low-level에서 수행하는 프로그램 작동 방식을 이해할 수 있다. WinDbg(윈도우 운영체제), gdb(리눅스, 맥OS 운영체제) 등의 디버깅 도구를 이용해 관찰할 수 있다.

#### 레지스터의 종류
1. 프로그램 카운터 (PC, Program Counter)
- 메모리에서 다음으로 읽어 들일 명령어의 주소를 저장하는 곳이며, 명령어 포인터(IP, Instruction Pointer)라고 부르는 CPU도 있다. 다음으로 읽어 들일 메모리 주소가 1씩 증가하지만 언제나 증가만 하진 않는다. if 조건과 같은 조건이 참이 되거나 리턴문을 실행하는 경우 프로그램이 순차적으로 실행되지 않는다. 순차적이지 않은 경우 프로그램 카운터 값이 임의의 위치로 변경
2. 명령어 레지스터 (IR, Instruction Register)
- 해석할 명령어, 즉 메모리에서 방금 읽어 들인 명령어를 저장하는 레지스터로 CPU의 제어장치는 명령어 레지스터 속 명령어를 해석한 뒤 ALU(산술논리연산장치)를 통해 연산을 수행하거나 다른 부품으로 제어 신호를 보내 해당 부품을 작동시킬 수 있다.
3. 범용 레지스터 (general purpose register)
- 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터로 명령어, 데이터, 주소 모두를 저장할 수 있다. CPU 내부에는 여러 개의 범용 레지스터가 존재한다.
4. 플래그 레지스터 (flag register)
- 연산의 결과 혹은 CPU 상태의 부가 정보를 알 수 있는 **플래그** 값을 저장할 수 있는 레지스터이다.
- 플래그 : 명령어를 처리하는 과정에서 반드시 참조해야 할 상태 정보를 의미하는 비트로 부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그가 존재한다.
- 부호 플래그 : 연산 결과의 부호
- 제로 플래그 : 연산 결과가 0인지의 여부
- 캐리 플래그 : 올림수나 빌림수가 발생했는지 여부
- 오버플로우 플래그 : 오버플로우 발생 여부
- 인터럽트 플래그 : 인터럽트 가능 여부
- 슈퍼바이저 플래그 : 커널모드인지, 사용자 모드인지 여부
5. 스택 포인터 (stack pointer)
- 스택처럼 사용하자고 약속된 메모리 영역을 스택 영역이라고 하는데, 스택 포인터란 최상단 스택 데이터 위치를 가리키는 특별한 레지스터를 말한다. 마지막으로 스택에 저장된 데이터의 위치를 가리키는 레지스터이자 스택이 채워진 정도를 나타내는 레지스터라고 볼 수 있다.

### 인터럽트
---
- 인터럽트는 다양한 상황에서 발생하는데, 임의로 발생이 가능하고 잘못된 프로그램으로 인해 발생하기도 하며 효율적인 입출력을 위해 사용되기도 한다.
- 인터럽트 : '방해하다, 중단시키다' 라는 의미로 CPU의 작업을 방해하는 신호를 의미한다. **동기 인터럽트와 비동기 인터럽트**로 나뉠 수 있다. 동기 인터럽트(synchronous interrupts)는 CPU에 의해 발생하는 인터럽트로 프로그래밍 오류와 같은 예외적인 상황을 마주쳤을 때 발생하는 인터럽트로 예외(exception)이라고도 한다. 비동기 인터럽트(asynchronous interrupts)는 입출력장치에 의해 발생하는 인터럽트로 완료가 되었을 때 보내는 알림의 역할을 한다고 생각하면 된다. 비동기 인터럽트는 하드웨어 인터럽트와 같은 의미이다.

#### 하드웨어 인터럽트
- 효율적으로 명령어를 처리하기 위해 사용되는 인터럽트. 만약 인터럽트를 사용하지 않는다면 입출력장치의 완료 여부를 주기적으로 확인해야 하며, 이는 폴링이라는 기법이라고 부르는데 이렇게 주기적으로 확인을 하게 된다면 사이클 낭비가 발생하며 효율적으로 처리할 수 없는 단점이 있다. 이를 해결하기 위해 사용되는 것이 **하드웨어 인터럽트**이며, 하드웨어 인터럽트를 사용함으로써 온전히 다른 작업을 처리하며 인터럽트가 올 때만 확인하면 되니 효율적으로 사용할 수 있게 되는 것이다.
- 인터럽트 요청 신호(interrupt request) : CPU에게 인터럽트의 가능 여부를 확인하는 단계
- 인터럽트 플래그(interrupt flag) : CPU가 인터럽트 요청을 수용하기 위해서 사용되는 플래그 레지스터
- 하드웨어 인터럽트에는 무시할 수 없는 인터럽트, 즉 막을 수 없는 인터럽트(non maskable interrupt)와 플래그로 막을 수 있는 인터럽트(maskable interrupt)로 분류된다.
- 인터럽스 서비스 루틴 (ISIR, Interrupt Service Routine) : 인터럽트를 처리하기 위한 프로그램으로, 인터럽트 핸들러라고도 한다. 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램. 인터럽스 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다는 인터럽트를 처리한다는 말이다. 인터럽트 서비스 루틴은 입출력장치마다 각기 다르게 가지고 있으며, '인터럽트가 발생하면 어떻게 행동해야 할지'를 알려 주는 프로그램이다.
- 인터럽트 벡터 (interrupt vector) : 인터럽트 서비스 루틴을 식별하기 위한 정보로, 버스를 통해 인터럽트 벡터를 전달받는다. 처음부터 특정 인터럽트 서비스 루틴을 실행할 수 있다. CPU가 작업을 수행하는 도중 프린터 인터럽트가 발생한 경우, CPU는 전달받은 인터럽트 벡터를 참조하여 프린터 인터럽트 서비스 루틴의 시작 주소를 알아내고, 이 시작 주소부터 실행하면서 인터럽트 서비스 루틴을 실행한다.
- 이러한 여러 인터럽트 특징들로 보아 정리하자면 **인터럽트 서비스 루틴을 실행하고 본래 수행하던 작업으로 돌아오는 것**이 CPU가 인터럽트를 처리한다는 것이다. 그러나 CPU가 인터럽트를 처리하기 위해선 지금까지의 작업 순서들을 어딘가에 백업을 해야하는데, 이러한 백업은 메모리 내 스택에 진행한다. 인터럽트 서비스 루틴이 종료되면 백업된 메모리 내 스택에서 작업들을 불러와 수행하던 작업들을 다시 재개한다.

#### 예외
- 예외의 종류에는 폴트, 트랩, 중단, 소프트웨어 인터럽트 등이 있는데, 예외가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리한다. 그러고 나서 예외를 처리하면 본래의 작업으로 돌아와 실행을 재개한다. 예외가 발생한 명령어부터 실행하느냐, 다음 명령어부터 실행하느냐에 따라 폴트와 트랩으로 구분지을 수 있다.
- 폴트(fault) : 예외를 처리한 직후에 예외가 발생한 명령어부터 실행을 재개하는 예외. 폴트가 발생한 명령어부터 다시 실행해나가는 것.
- 트랩(trap) : 예외를 처리한 직후에 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외. 대표적인 사례로는 디버깅 브레이크 포인트를 말할 수 있다. 디버깅이 끝나고 나면 트랩이 발생한 그 다음 명령어부터 실행해 나가는 특징을 가지고 있다.
- 중단(abort) : CPU가 실행중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
- 소프트웨어 인터럽트(software interrupt) : 시스템 콜이 발생했을 때 발생하는 예외로 소프트웨어에서 강제로 인터럽트를 만든 경우를 의미한다.

### CPU 성능 향상 설계법
---
- 조금 더 빠른 CPU를 만들기 위해 새로운 CPU 설계 및 명령어 처리 기법들을 고안해내고 있으며, 클럭과 코어, 스레드 등 CPU 성능 향상과 관련된 개념들이 소개되는 부분이다.

#### CPU 클럭 속도
- 클럭(clock) : 컴퓨터의 부품을 빠르게 움직일 수 있게 하는 시간의 단위, 클럭의 속도는 헤르츠 단위로 측정되는데 이는 1초에 몇 번 반복되는지를 나타내며 1초에 100번 반복이 된다면 CPU의 클럭 속도는 100Hz라고 볼 수 있다. 최근 CPU 속도는 매우 빨라져 기가헤르츠(GHz) 단위로 측정하는 것이 일반적이라고 여겨지고 있다. 하지만 클럭 속도를 필요 이상으로 높이면 발열이 심해져 성능이 좋아진다고 볼 수는 없다. 그만큼 수명이 빨리 닳기 때문이다.

#### 멀티코어와 멀티스레드
- 코어(core) : 명령어를 읽어 들이고, 해석하고, 실행하는 부품 한 개의 단위를 의미하는데 개수는 얼마든지 존재할 수 있다. CPU 코어가 만약 8개라면 옥타코어라고 부르며, 명령어를 읽어 들이고 해석하고 실행하는 부품이 8개라는 소리이다. 이렇게 여러 단위를 가지고 있는 CPU를 멀티코어 CPU, 혹은 멀티코어 프로세서 라고도 부른다.
- 스레드(thread) : '실행 흐름의 단위'로써 하드웨어적인 스레드와 소프트웨어적인 스레드로 구분할 수 있다. 
- 하드웨어 스레드 : 하나의 코어가 동시에 처리하는 명령어의 단위이다. 멀티스레드 프로세서 혹은 멀티스레드 CPU는 여러 명령어를 동시에 처리하는 CPU를 통칭하며, 한 번에 하나의 명령어를 처리한다면 이는 1코어 1스레드 CPU라고 한다. 하드웨어 스레드를 논리 프로세서라고도 한다. 왜냐하면 한 번에 하나의 명령어를 처리하는 CPU의 개수를 통칭하기 때문이다.
- 소프트웨어 스레드 : 하나의 프로그램에서 독립적으로 실행되는 단위, 메모리에 적재된 해당 프로그램을 구성하는 여러 부분이 동시에 실행될 수 있다는 말과 같다.
- 병렬성(parrallelism) : 작업을 물리적으로 동시에 처리하는 성질ㅇ이고, 같은 시점에 여러 작업을 동시에 처리할 수 있는 것을 의미한다.
- 동시성(concurrency) : 동시에 작업을 처리하는 것처럼 보이는 성질, 사용자의 눈에는 마치 여러 작업이 동시에 처리되는 것 처럼 보이도록 빠르게 작업을 번갈아가며 처리하는 경우. 하지만 물리적으로 같은 시점에 여러 작업이 동시에 처리되는 것은 아님.

### 파이프라이닝
---
- 명령어 병렬 처리 기법(ILP, Instruction-Level Parallelism) : 여러 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시킴으로써 CPU의 성능을 높이는 기법으로 명령어 파이프라이닝이 존재한다. 같은 단계가 겹치지 않는 다면 CPU가 단계를 동시에 실행할 수 있다는 것이다. 명령어는 인출, 해석, 실행, 결과 저장의 프로세스가 있는데 겹치지 않는 다면 하나의 명령어가 인출되는 동안 다른 명령어를 실행할 수 있는 구조라는 것이다.
- 슈퍼스칼라 : 대부분의 CPU는 여러 개의 파이프라인을 사용하며, 여러 명령어 파이프라인을 포함하는 구조를 슈퍼스칼라(superscalar)라고 한다.
- CISC (Complex Instruction Set Computer) : 다채로운 기능을 지원하는 복잡한 명령어들로 구성된 명령어 집합으로 적은 수의 명령어로도 프로그램을 실행. 인텔의 x86 혹은 x86-64 CPU가 이에 해당한다. 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기 및 실행되기까지의 시간이 일정하지 않고, 하나의 명령어 실행에 여러 클럭 주기가 필요.
- RISC (Reduced Instruction Set Computer) : 활용 가능한 명령어가 CISC보다는 적으나, 짧고 규격화된 명령어 (1클럭 내외로 실행되는)를 지향한다. 애플의 M시리즈 CPU가 이에 해당한다. 크기가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에 파이프라이닝에 최적화.
- 파이프라이닝이 실패하는 경우를 **파이프라인 위험**이라고 부르며, 데이터 위험과 제어 위험, 구조적 위험으로 구분 가능하다.
- 데이터 위험(data hazard) : 명령어 간의 데이터 의존성에 의해 발생한다. 동시에 처리할 수 없고 이전 명령어를 끝까지 실행해야만 비로소 실행 가능한 의존성 있는 명령어를 겹쳐서 실행하는 경우 파이프라인이 제대로 작동하지 않을 수 있는 문제가 있다.
- 제어 위험(control hazard) : 프로그램 카운터의 갑작스러운 변화에 의해 발생. JUMP, CONDITIONAL JUMP, 인터럽트 등으로 인해 프로그램 실행의 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생기면 미리 인출하거나 해석 중인 명령어들은 아무 쓸모가 없어지게 되는 문제를 의미한다.
- 구조적 위혐(structual hazard) : 서로 다른 명령어가 동시에 ALU, 레지스터 등 같은 CPU 자원을 활용하려고 할 때 발생하는 문제로 자원 위험이라고도 부른다.

## 메모리
---
- 실행중인 프로그램은 메모리에 저장되며, CPU는 메모리에 저장된 정보를 읽고, 쓰고, 실행한다.

### RAM
----
- 메인 메모리 역할을 하는 하드웨어에는 RAM과 ROM이 있는데, 메인 메모리는 보통 RAM을 지칭하는 경우가 많다. RAM은 전원을 끄면 저장된 데이터와 명령어가 날아가는 휘발성 저장장치.
- CPU는 보조기억장치에 저장된 프로그램을 곧바로 가져와 실행할 수 없기 때문에 프로그램을 보관하고 있는 보조기억장치에서 메모리로 복사해와 사용해야 한다. RAM의 용량이 충분히 크면 보조기억장치로부터 많은 데이터를 가져와 미리 RAM에 저장할 수 있기 때문에 많은 프로그램을 동시에 실행하는 데 유리하다.
- RAM : 임의 접근 메모리(Random Access Memory)으로 임의 접근이란 저장된 요소에 순차적으로 접근할 필요 없이 임의의 위치에 곧장 접근 가능한 방식. 직접 접근이라고도 한다.
- 순차 접근(sequential access) : 처음부터 순차적으로 메모리에 접근하는 방식으로, 어떤 위치에 접근하느냐에 따라 접근하는 시간이 달라질 수 있다.
- RAM의 종류 : DRAM, SRAM, SDRAM, DDR SDRAM

#### DRAM (Dynamic RAM)
- 저장된 데이터가 동적으로 변하는 특성. 시간이 지나면 저장된 데이터가 점차 사라지는 RAM이다. 일정 주기로 데이터를 재활성화 해야하는 단점이 있는데, 소비 전력이 낮고 저렴하며 집적도가 높아 메모리를 대용량으로 설계하기에 용이하기 때문에 자주 쓰인다.

#### SRAM (Static RAM)
- 저장된 데이터가 변하지 않는 RAM. 시간이 지나도 저장된 데이터가 사라지지 않는 RAM이지만 전원이 공급되지 않으면 저장된 내용이 소실되는 것은 마찬가지. DRAM과 비교해 속도가 빠르지만 전력이 크고 가격도 비싸 캐시 메모리 등에서 사용된다.

#### SDRAM (Synchronous Dynamic RAM)
- 클럭 신호와 동기화된 발전된 형태의 DRAM을 말한다. 클럭 타이밍에 맞춰 CPU와 정보를 주고 받을 수 있는 DRAM을 의미한다.

#### DDR SDRAM (Double Data Rate SDRAM)
- 대역폭을 넓혀 속도를 빠르게 만든 SDRAM을 말한다. 대역폭이란 데이터의 주고받을 길의 너비를 말하는데, 너비가 SDRAM에 비해 두 배가 된 것과 같다고 볼 수 있다. DDR SDRAM은 한 클럭 당 하나씩 데이터를 주고 받을 수 있는 SDRAM보다 전송 속도가 두 배 가량 빠르다.
- DDR2 SDRAM은 DDR SDRAM보다 대역폭이 두 배 넓은 SDRAM을 말하며, DDR SDRAM보다 대역폭이 2배로 넓고, DDR3 SDRAM은 DDR2 SDRAM보다 2배로 넓어지는 이러한 특징들을 가지고 있다.

### 엔디안
- 현대의 메모리는 대부분 데이터를 바이트 단위로 저장하고 관리하는데, 예를 들어 16진수인 1A2B3C4D는 1A, 2B, 3C, 4D 이렇게 4개의 주소로 저장되는 방식으로 진행되고 있다고 볼 수 있다. 16진수 1개를 저장하는데에는 4비트가 필요하며, 2개를 저장하는데에는 8비트(즉 1바이트)가 필요하다.
- 빅엔디안과 리틀 엔디안은 어떤 순서로 바이트를 저장하는지에 따라 구분할 수 있다.
- 빅 엔디안(big endian) : 낮은 번지의 주소에 상위 바이트로부터 저장하는 방식. 가장 큰값부터 차례대로 가장 낮은 번지에 저장하는 방식으로 1A, 2B, 3C, 4D의 경우 1A가 최상위 바이트이기 때문에 1A 부터 순차적으로 저장이 된다. 일상적으로 숫자 체계를 읽고 쓰는 순서와 동일하기 때문에 메모리 값을 직접 읽거나 디버깅할 때 편리하다.
- 리틀 엔디안(little endian) : 낮은 번지의 주소에 하위 바이트로부터 저장하는 방식. 가장 작은값부터 차례대로 가장 낮은 번지에 저장하는 방식으로 1A, 2B, 3C, 4D의 경우 4D가 최하위 바이트이기 때문에 4D부터 저장하는 방식이다. 수치 계산에 편리하다는 장점이 있다. 자리 올림이 편해지며, 가장 작은값부터 저장되어 있는 데이터의 시작점에서 수치를 계산해 나가거나 자리올림할 수 있다.
- MSB(Most Significant Bit) : 숫자의 크기에 가장 큰 영향을 미치는 유효 숫자. 가장 왼쪽에 있는 비트, MSB는 빅 엔디안 방식에 따른다고 볼 수 있다.
- LSB(Least Significant Bit) : 숫자의 크기에 가장 적은 영향을 미치는 유효 숫자. 가장 오른쪽에 있는 비트. LSB는 리틀 엔디안 방식에 따른다고 볼 수 있다.

### 캐시 메모리
---
- 빈번히 메모리에 접근해야 하는 CPU의 속도가 느린 단점을 보완하기 위해 만들어진 메모리를 캐시 메모리라고 한다.
- 캐시 메모리(cache memory) : 연산 속도와 메모리 접근 속도의 차이를 줄이기 위해 탄생한 저장장치로, CPU와 메모리 사이에 위치한 SRAM 기반의 저장 장치이다. CPU가 사용할 일 부 데이터를 미리 캐시 메모리로 가져와 활용하자는 것이며, 접근이 빠르게 해주도록 도와주는 장치이다. 가장 가까운 거리 순으로 L1 캐시, L2 캐시, L3 캐시라고 부른다. 속도는 L1이 제일 빠르고, 메모리의 크기는 L3가 제일 크다. 캐시 메모리의 크기가 CPU 성능에 영향을 미치기 때문에 CPU 규격을 판단할 때 함께 확인하면 좋다.
- 분리형 캐시(split cache) : L1I 캐시와 L1D 캐시, 즉 명령어와 데이터를 구분하여 저장하는 캐시 메모리를 의미한다.

#### 캐시 히트와 캐시 미스
- 캐시 메모리는 CPU가 사용할 법한 정보들을 저장하는 경향을 보여준다.
- 캐시 히트(cache hit) : 캐시 메모리가 예측하여 저장한 데이터가 CPU에 의해 실제로 사용되는 경우
- 캐시 미스(cache miss) : 캐시 메모리가 예측하여 저장했지만 틀린 예측으로 인해 CPU가 메모리로부터 필요한 데이터를 직접 가져와야 하는 경우, 캐시 메모리의 이점을 활용할 수 없을 경우
- 캐시 적중률(cache hit ratio) : 캐시가 히트되는 비율

#### 참조 지역성의 원리
- 참조 지역성의 원리 (locality of reference, principle of locality) : 특정한 원칙에 따라 메모리로부터 가져올 데이터를 결정한다.
- 시간 지역성 : CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향, 프로그래밍 언어에서 변수를 보면 시간 지역성을 대표한다고 볼 수 있다. 변수는 저장된 값을 한 번만 사용하지 않고, 같은 메모리 공간에 여러번 접근하기 때문에 이러한 시간 지역성을 잘 보여주는 사례라고 볼 수 있다.
- 공간 지역성 : CPU는 접근한 메모리 공간의 근처에 접근하려는 경향, 배열은 공간 지역성을 단적으로 보여준다. 공간 접근성을 무시하는 경우에는 성능이 낮아지고, 접근하는 방식이 달라지는 경우 프로그램 성능에 많은 영향을 미칠 수 있다.

#### 캐시 메모리의 쓰기 정책과 일관성
- CPU가 캐시 메모리에 데이터를 쓸 때 캐시 메모리에 쓰일 데이터와 메모리 상의 데이터가 일관성을 유지해야 한다. 만약 일관성을 유지해야 하는데 값을 변경하고 싶은 경우가 있을텐데, 이런 경우에 바로 메모리의 값을 무작정 변경하는 것은 좋지 않다. 이렇듯 캐시 메모리의 값과 메모리의 값을 일관되게 유지함과 동시에 값을 변경하는 방법에는 두 가지 방법이 있다. 즉시 쓰기와 지연 쓰기.
- 즉시 쓰기 (write-through) : 메모리를 항상 최신 상태로 유지하여 캐시 메모리와 메모리 간의 일관성이 깨지는 상황 방지하는 방법. 하지만 데이터를 쓸 때마다 메모리를 참조해야 하기 때문에 버스의 사용 시간과 쓰기 시간이 늘어난다는 단점이 있다.
- 지연 쓰기 (write-back) : 캐시 메모리에만 값을 변경해놓고, 추후에 수정된 데이터를 한 번에 반영하는 방법. 즉시 쓰기 방식에 비해 속도는 빠르지만 일관성이 깨질 수 있는 위험을 감수해야 한다.
- 꼭 메모리 간의 일관성만 불일치 하는 경우만 있는 것이 아닌 다른 코어가 사용하는 캐시 메모리와도 불일치가 발생할 수 있다.

#### 캐시 일관성 프로토콜
- 각 프로세서가 가진 로컬 캐시 간의 데이터 일관성 유지, 스누핑 프로토콜과 디렉터리 프로토콜 두 가지 방법이 있다.
- 스누핑 프로토콜 : 각 캐시가 버스를 감지하며 다른 캐시에 대한 변경사항을 확인
- 디렉터리 프로토콜 : 중앙 디렉터리가 각 데이터의 복사본 위치를 추적하고 관리하는 방식
- MESI 프로토콜 : Modified, Exclusive, Shared, Invalid 4가지 상태로 캐시 데이터를 관리하는 방식의 프로토콜

## 보조기억장치와 입출력장치
---
- 보조기억장치는 메모리의 휘발성을 보완하는 동시에 메모리보다 큰 저장 공간을 제공하는데, 이러한 저장 정보들을 안정적이고 안전하게 관리하는 방법인 RAID에 대해 알아보자.

### RAID
---
- 오늘날 대중적으로 활용되는 보조기억장치는 총 2개인데, 하드 디스크 드라이브(HDD)와 플래시 메모리 기반 저장장치(SSD, USB 등)가 있다. 하드 디스크는 동그란 원판(플래터)에 있는 뾰족한 리더기인 헤드를 통해 플래터에 저장된 데이터에 접근할 수 있다. 플래시 메모리는 전기적인 방식으로 데이터를 읽고 쓰는 반도체 기반의 저장장치이다.
- 보조기억장치는 전원이 꺼져도 데이터를 안전하게 보관하여야 하고 CPU가 필요로 하는 정보를 조금이라도 빠르게 메모리에 전달하는 것이 중요한데, 이런 부분들을 사용하는 기술을 RAID라고 한다.
- RAID (Redundant Array of Independent Disks) : **데이터의 안정성 혹은 성능**을 확보하기 위해 여러 개의 독립적인 보조기억장치를 마치 하나의 보조기억장치처럼 사용하는 기술. RAID를 구성하는 방법에는 여러 가지가 있으며 이를 **RAID 레벨**이라고 한다. RAID0, RAID1, RAID2 등의 이름으로 불리운다.
- RAID 레벨마다 각기 다른 장단점을 가지고 있어 어떤 상황에서 무엇을 최우선으로 원하는지에 따라 최적의 RAID 레벨은 달라질 수 있다는 것을 염두해야 한다.

#### RAID0
- 데이터를 여러 보조기억장치에 단순하게 나누어 저장하는 구성 방식. 줄무늬처럼 분산되어 저장되어 있어 이러한 데이터들을 stripe이라고 하며, 분산하여 저장하는 동작을 striping이라고 한다.
- 빠른 입출력 속도를 가지고 있다는 것이 장점인데, 여러 번에 걸쳐 읽고 써야 했을 데이터를 한번에 사용할 수 있기 때문이다. 4TB인 저장장치 1개를 읽고 쓰는 속도보다 RAID0으로 구성된 1TB 저장장치 4개의 속도가 이론상 4배에 빠르다는 것이다.
- 그러나 저장된 정보가 안전하지 않다는 단점도 있다. 하나의 하드 디스크에 문제가 발생한다면 나머지 하드 디스크 데이터도 불완전한 데이터가 되기 때문이다.

#### RAID1
- 완전한 복사본을 만들어 저장하는 구성 방식으로 미러링(mirroring)이라고도 부른다.
- 복구가 간단하고 안정성이 높은 장점이 있으나 원본과 복사본을 만들어 써야 하기 때문에 RAID0보다 쓰기 속도가 느려지는 단점이 있고, 복사본이 저장된 크기만큼 사용 가능한 용량이 적어지는 단점도 있다.

#### RAID4
- 패리티 정보를 저장하는 디스크를 따로 구성하는 방식을 사용하는데, 여기서 패리티(parity)란 오류를 검출할 수 있는 정보를 의미한다. 이렇게 패리티를 두어 사용하게 된다면 적은 하드디스크로도 안전하게 데이터를 보관할 수 있다.
- 하지만 패리티를 저장하는 장치에 병목 현상이 발생한다는 것이다. 패리티를 저장하는 디스크에도 새로운 데이터가 저장될 때마다 데이터를 쓰게 되므로 작업을 진행하고, 굉장히 바빠진 패리티 하드디스크에서 병목이 발생할 수 있는 것이다.

#### RAID5
- 패리티를 분산하여 저장하는 구성방식이다. 이렇게 분산하여 패리티를 저장하게 된다면 RAID4의 단점인 병목 현상을 보완할 수 있다.

#### RAID6
- 구성은 기본적으로 RAID5와 같지만 서로 다른 2개의 패러티를 두는 방식을 사용하며, 오류를 검출하고 복구할 수 있는 수단이 2개가 생긴 것과 같다.
- RAID6는 RAID4나 RAID5에 비해 안정성이 높으나 새로운 정보나 데이터를 저장할 때마다 함께 저장해야 되는 패리티가 디스크별 2개이므로 RAID5에 비해 쓰기 속도가 느리다는 단점이 있다.

#### Nested RAID
- 학습한 RAID의 레벨들을 혼합하여 새로운 RAID 레벨을 만들어내는 방식으로, RAID0과 RAID1을 합한 RAID10이 있고 RAID0과 RAID5를 합한 RAID 50도 있다. 이런식으로 레벨을 혼합한 방식을 Nested RAID라고 한다.

### 입출력 기법
---
- 입출력장치와 보조기억장치는 완전히 배타적인 개념이 아니다. 메모리를 보조하는 임무를 수행하는 특별한 입출력장치가 보조기억장치이다. 여기에서는 다양한 입출력장치들이 컴퓨터 내부와 정보를 주고받는 방식인 입출력 기법에 대해서 알아보겠다.

#### 장치 컨트롤러와 장치 드라이버
- 장치 컨트롤러(drive controller) : 입출력장치와 CPU가 정보를 주고 받을 수 있도록 연결해주는 중개자 역할의 하드웨어.
- 장치 드라이버(device driver) : 장치 컨트롤러마다 작동을 시킬 수 있도록 하는 프로그램. 장치 컨트롤러의 동작을 알고, 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있도록 하는 프로그램. 대중적인 장치 드라이버의 경우에는 기본적인 운영체제에 포함이 되어 있으나, 전형적이지 않은 장치 드라이버는 별도로 설치하여 CPU와 소통할 수 있도록 하게 해주어야 한다.
- CPU와 장치 컨트롤러가 정보를 주고받는, 입출력 작업을 수행하는 방법에는 크게 프로그램 입출력, 인터럽트 기반 입출력, DMA 입출력 3가지 방식이 있다.

#### 프로그램 입출력
- 프로그램 속 명령어로 입출력 작업을 수행하는 방법. 입출력 명령어를 통해 장치 컨트롤러와 상호작용 하고, 입출력 작업을 수행한다.
- 고립형 입출력(isolated I/O) : 입출력장치에 접근하는 주소와 메모리에 접근하는 주소를 별도의 주소 공간으로 간주하는 방식. 입출력장치만을 위한 주소 공간에 접근하려면 별도의 입출력 명령어가 필요함.
- 메모리 맵 입출력(memory mapped I/O) : 입출력장치에 접근하는 주소 공간과 메모리에 접근하는 주소 공간을 구분하지 않고, 메모리에 부여된 주소 공간 일부를 입출력장치를 식별하기 위한 주소 공간으로 사용하는 방식. 입출력 전용 명령어가 별도로 필요하지 않다.

#### 인터럽트 기반 입출력: 다중 인터럽트
- 다중 인터럽트 처리 : 여러 개의 입출력 장치에서 인터럽트가 동시다발적으로 발생하는 경우 처리하는 방식. 우선순위가 더 높은 인터럽트가 우선적으로 처리되는 경우가 일반적이다.
- NMI(Non-Maskable Interrupt) : 무시할 수 없는 인터럽트로, 무시할 수 없는 인터럽트는 우선순위가 높게 잡히기 때문에 먼저 처리하게 된다.
- 프로그래머블 인터럽트 콘트롤러(PIC, Programmable Interrupt Controller) : 다중 인터럽트를 처리하는 하드웨어. 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤, CPU에게 지금 처리해야 할 하드웨어 인터럽트가 무엇인지를 알려주는 장치. PIC에는 여러 핀들이 있는데 각각의 핀에는 CPU에게 하드웨어 인터럽트 요청을 보낼 수 있도록 약속된 하드웨어가 연결되어 있다. 하지만 무시할 수 없는 인터럽트인 NMI까지 우선순위를 판별해주진 않는다.

#### DMA 입출력
- 프로그램 기반의 입출력과 인터럽트 기반의 입출력에 공통점은 CPU가 입출력장치와 메모리 간의 데이터 이동을 주체해야 하며, 이동하는 데이터들도 반드시 CPU를 거친다는 점이다. 하지만 모든 데이터가 CPU를 거치게 된다면 CPU의 부담이 커지게 될 것이다. 이를 해결하기 위해 나온 방식이 DMA(Direct Memory Access)다.
- CPU는 장치 컨트롤러부터 데이터를 하나씩 읽어 레지스터에 적재하고 적재한 데이터를 하나의 메모리에 저장하고 입출력장치에 내보낼 때는 메모리로부터 데이터를 하나씩 읽어 레지스터에 적재하고 입출력장치에 하나씩 내보내는 방식으로 진행된다.
- DMA : 직접 메모리에 접근할 수 있는 입출력 기능으로 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요하다. DMA 컨트롤러는 시스템 버스에 연결되고 입출력장치들의 장치 컨트롤러들은 입출력 버스(input/output bus)라는 입출력장치 컨트롤러의 전용 버스와 연결.
- DMA 입출력 진행 방식 : ① CPU가 DMA 컨트롤러에게 입출력장치의 주소, 수행할 연산 등의 정보와 함께 입출력 장치 작업 명령 ② 장치 컨트롤러와 DMA 컨트롤러가 상호작용하여 입출력 작업 수행 ③ DMA 컨트롤러가 입출력 작업이 끝나면 CPU에게 인터럽트를 걸어 작업의 종료를 알림.

#### 사이클 스틸링
- 버스는 공용자원이며, 두 개의 장치가 하나의 버스를 이용할 수 없다.
- DMA 컨트롤러는 시스템 버스를 통해 메모리에 직접 접근이 가능하지만, 시스템 버스는 동시 사용이 불가능하다. CPU가 사용중일 때는 DMA 컨트롤러가 사용할 수 없고, 반대의 경우도 마찬가지이다.
- DMA 컨트롤러는 CPU가 시스템 버스를 사용하지 않을 때마다 조금씩 사용하거나 CPU가 시스템 버스 사용을 양보하게 된다. 이렇게 DMA의 시스템 버스 이용을 **사이클 스틸링(cycle stealing)**이라고 한다.

#### PCIe (Perlpheral Component Interconnect express)
- 대표적인 입출력 버스로, PCI라는 입출력 버스의 발전된 형태로 메인 보드에서 가장 대중적으로 볼 수 있는 입출력 버스 중 하나.
- PCIe 버전에 따라 최대 속도가 달라질 수 있고 PCIe 버스가 여러 레인을 이용해 정보를 주고받을 수 있다는 것이다. PCIe 버스는 지속적으로 발전하고 있으므로 여러 버전들이 존재하며, 버전에 따라 지원되는 최대 속도가 다르다.
- 레인(lane) : PCIe 버스를 통해 정보를 송수신하는 단위. 통신을 주고받는 선로의 수와 같은 개념으로 통신을 한 번에 주고 받을 수 있는 양을 확인할 수 있다.
- PCIe 1.0(250MB/s), PCIe 2.0(500MB/s), PCIe 3.0(985MB/s), PCIe 4.0(1,969MB/s), PCIe 5.0(3.94GB/s), PCIe 6.0(7.56GB/s), PCIe 7.0(15.13GB/s)

### GPU의 용도와 처리 방식
- GPU(Graphical Processing Unit) : 그래픽 처리 장치로 화면에 그림을 그리는 등 대량의 그래픽 연산을 위해 태어난 장치지만, 최근데는 딥러닝 연산과 가상화폐 채굴 등 다양한 분야에 대한 연산이 가능해졌는데 이를 GPGPU(General Purpose GPU)라고 한다.
- GPU 코어의 개수가 많은데 단일 GPU 코어는 CPU의 단일 코어보다 성능이 떨어지지만 수백 개에서 많게는 수천 개의 코어가 GPU에 포함되어 있다. 이는 병렬 처리에 용이하다는 점을 보여준다.
- 병렬 처리(parallel processing) : 여러 개로 쪼개진 문제를 각 코어에서 처리하는 연산 방식이다. 어떠한 크고 복잡한 문제를 쉽고 간단한 여러 문제로 쪼갠 뒤 쉽고 간단한 문제를 처리할 수 있는 수단을 동시에 동원하여 빠르게 문제를 해결하는 방식.
- 그렇다고 GPU는 CPU를 아예 대체할 수 있는 것은 아니다. GPU 단독으로 운영체제를 실행하거나 코어 내에서 복잡한 명령어 병렬 처리르 수행하는 등의 다양한 작업을 수행할 수 없는데, GPU는 메모리의 대역폭을 넓혀 최대한 많은 코어가 많은 작업을 받아 처리하는 것을 목표로 한다. 이러한 특성으로 보면 GPU는 보조프로세서라고 부를 수 있다.
- GPU는 키보드, 마우스와 달리 직접 소스 코드를 통해 수행할 작업을 지정하는 경우가 많은데, 여기서 대표적으로 사용되는 것이 NVIDIA에서 개발한 CUDA라는 프로그래밍 모델이다.
- CUDA : 크게 CPU가 실행할 코드인 호스트 코드(host code)와 GPU가 실행할 코드인 디바이스 코드(device code)로 구성되어 있다. 디바이스 코드가 cuda로 지정이 되어 있다면 GPU가 실행할 디바이스 코드가 GPU 메모리로 복사, GPU는 복사된 디바이스 코드를 실행해 CPU에 실행 결과를 알리게 된다.